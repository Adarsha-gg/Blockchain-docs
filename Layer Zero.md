2024-07-01 23:05

Status:

Tags:[[Blockchain]]

# Layer Zero
 
### 1. Sending
So I give all the required params and call the lzSend onchain with a lz endpoint.  Based on the data a nonce is generated for each packet. The packet is encoded and sent to security stack and exectuor which completes the transaction by emitting PacketSent event. ( for this to happen the Messagelib must be specified)

***DVNs*** - Decentralized Verifier Networks (yk what they do :))
***OApps*** - Omnichain Applications ( basically not limited to single chain)
### 2. Verify:
so different DVNs then verify the transaction independently with their own methods. but only the DVNs configured by the messageLib using the OApp can submit it. (prolly has to do with certain blockchain ko verifier or smth yestai)

### 3. commit
So once the messageLib's security stack verifies it, it marks the message as verifiable and the exectutor commits the packet to endpoint which makes it ready to be executed.

### 4. Receive
so the destination endpoint checks if the packet given by executor matches the "message"(see the difference one is packet another is message) verified by DVNs and sent by the MessageLib. then after verification lzRecieve is called on commited message to process the "packet" using the OApp's logic. and then the "message" is recieved by the Receiver Oapp contract

### Message design patterns
There are a lot of message design patterns. 
**Ab** - simple just send from chain A to chain B.

**Aba** - Send from a to b and get smth back to A or any other chain

**Composed** - Didnt get this (learn packets and messages) ( i think what this does is send smth from 
A to B (this counts as a->b) and then again do smth in B so that makes it composed?)

**Composed ABA** - composed but can return back (read upper description and then whatever was done after B is returned to another chain)

**Batch send** - make a call to MANY blockchains at once. like a->b,c,d,e,f ... in same call


### DVN config
so there are diff types of DVNs and the user can set a config to use certain type of DVNs of their choice to verify the transactions happening in the app. They then go to security stack for checking.
EG- I choose DVNa and DVNb then if it'll only verify the transaction if these 2 verify it, not the majority. another eg. i chosed DVNa and DVNb and verification is done by 4 nodes even if 3 of them say its verified but DVNa says its not, the txn isn't verified. Also if most dvns are faulty u choose the remaining wones which may be more exp. Monopoly stuff? but if this happens run our own DVN ez.


### How it works?
So you setup endpoints on both your blockchains and send values with gas fee of the source blockchain only to pay in both the blockchains and also the security stack and executor (EXPENSIVE). So the source endpoint assings a nonce which is then concatinated with Path (which includes things like endpoint iDs, sender , reciver etc etc) and hashed to generate a global ID which is used to track DVNs and executors

### Liveness of network
for this to work both the blockchain should be "live" in working conditions. In the middle if the DVNs experience fault we can just change it. and if the exectuor expereinces fault, another one will do it cuz whoever does it gets the gas fees.

### Execution of nonces
Since it runs in a periodic order. Say nonce N can only run if all N-1 nonces have already run, what if 1 nonce gets stuck? like it stops the program for every other txn until this is solved. Or is a nonce generated by a DVN limited to itself? like DVN-a generated upto 100 but DVN-b has generated to 1000 so there are in diff states kind of thingy.

## Questions:
How does the abstraction happen? like how can we pay for the destination chain's token using native token? -Relayers [now separated into security stack and executors] (they get some gas fee for doing this)

True Decentralization in cross-chain is impossible? whats the point of having interconnected blockchain then? defeats the whole purpose ?

What are packets? and messages? Learn how the web works ig

Wtf does censorship resistant even mean?

Lazy inbound nonce stuff

### Conclusion:
Bridges are faulty af / expensive / cant update much. ["We argue this append-only design is the only way to implement intrinsic security without compromising extensibility. In theory, a single non-upgradable MessageLib that is completely bug-free and perfectly optimized provides intrinsic end-to-end security, but is impractical even in this unrealistic scenario"] damn.
## ***References***
https://layerzero.network/how-it-works
-------------------
Linked mentions: